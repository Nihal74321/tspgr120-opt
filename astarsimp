import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from matplotlib.colors import ListedColormap
import heapq
from typing import List, Tuple, Optional

class AStar:
    def __init__(self, grid: np.ndarray):
        """
        Initialize A* pathfinder with a grid.

        Args:
            grid: 2D numpy array where 0 = free space, 1 = obstacle
        """
        self.grid = grid
        self.rows, self.cols = grid.shape

    def heuristic(self, a: Tuple[int, int], b: Tuple[int, int]) -> float:
        """Manhattan distance heuristic"""
        return abs(a[0] - b[0]) + abs(a[1] - b[1])

    def get_neighbors(self, pos: Tuple[int, int]) -> List[Tuple[int, int]]:
        """Get valid neighboring positions (4-directional movement)"""
        row, col = pos
        neighbors = []

        # 4-directional movement (up, down, left, right)
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

        for dr, dc in directions:
            new_row, new_col = row + dr, col + dc

            # Check bounds and obstacles
            if (0 <= new_row < self.rows and
                0 <= new_col < self.cols and
                self.grid[new_row, new_col] == 0):
                neighbors.append((new_row, new_col))

        return neighbors

    def reconstruct_path(self, came_from: dict, current: Tuple[int, int]) -> List[Tuple[int, int]]:
        """Reconstruct path from came_from dictionary"""
        path = [current]
        while current in came_from:
            current = came_from[current]
            path.append(current)
        return path[::-1]  # Reverse to get start->goal path

    def find_path(self, start: Tuple[int, int], goal: Tuple[int, int]) -> Optional[List[Tuple[int, int]]]:
        """
        Find path from start to goal using A* algorithm.

        Returns:
            List of (row, col) tuples representing the path, or None if no path exists
        """
        # Priority queue: (f_score, counter, position)
        open_set = [(0, 0, start)] #heapq for constant lookup 
        counter = 0

        # Track positions in open set for efficient lookup
        open_set_positions = {start}

        # Cost from start to each position
        g_score = {start: 0}

        # Estimated total cost from start to goal through each position
        f_score = {start: self.heuristic(start, goal)}

        # Track the path
        came_from = {}

        while open_set:
            # Get position with lowest f_score
            current_f, _, current = heapq.heappop(open_set)
            open_set_positions.discard(current)

            # Goal reached
            if current == goal:
                return self.reconstruct_path(came_from, current)

            # Explore neighbors
            for neighbor in self.get_neighbors(current):
                # Tentative g_score for neighbor
                tentative_g_score = g_score[current] + 1    

                # If we found a better path to neighbor
                # cond1 means we havent found the neighbour before, cond2 means the neighbor is cheaper to visit
                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g_score
                    # f = g(n) + h(n)
                    f_score[neighbor] = tentative_g_score + self.heuristic(neighbor, goal)

                    # Add to open set if not already there
                    if neighbor not in open_set_positions:
                        counter += 1
                        heapq.heappush(open_set, (f_score[neighbor], counter, neighbor))
                        open_set_positions.add(neighbor)

        return None  # No path found

class AStarVisualizer:
    def __init__(self, grid: np.ndarray):
        self.grid = grid
        self.astar = AStar(grid)

        # Color mapping
        self.colors = ['white', 'black', 'green', 'red', 'blue']
        self.cmap = ListedColormap(self.colors)

    def visualize_path(self, start: Tuple[int, int], goal: Tuple[int, int],
                      figsize: Tuple[int, int] = (10, 8)):
        """
        Visualize the grid and A* pathfinding result.

        Args:
            start: Starting position (row, col)
            goal: Goal position (row, col)
            figsize: Figure size for matplotlib
        """
        # Find the path
        path = self.astar.find_path(start, goal)

        # Create visualization grid
        vis_grid = self.grid.copy().astype(float)

        # Mark start and goal
        vis_grid[start] = 2  # Green for start
        vis_grid[goal] = 3   # Red for goal

        # Mark path
        if path:
            for pos in path[1:-1]:  # Exclude start and goal
                vis_grid[pos] = 4  # Blue for path

        # Create the plot
        fig, ax = plt.subplots(figsize=figsize)

        # Display the grid
        im = ax.imshow(vis_grid, cmap=self.cmap, vmin=0, vmax=4)

        # Add grid lines
        ax.set_xticks(np.arange(-0.5, self.grid.shape[1], 1), minor=True)
        ax.set_yticks(np.arange(-0.5, self.grid.shape[0], 1), minor=True)
        ax.grid(which="minor", color="gray", linestyle='-', linewidth=0.5)

        # Customize the plot
        ax.set_title(f'A* Pathfinding\nStart: {start}, Goal: {goal}', fontsize=14, fontweight='bold')
        ax.set_xlabel('Column')
        ax.set_ylabel('Row')

        # Add legend
        legend_elements = [
            patches.Patch(color='white', label='Free Space'),
            patches.Patch(color='black', label='Obstacle'),
            patches.Patch(color='green', label='Start'),
            patches.Patch(color='red', label='Goal'),
            patches.Patch(color='blue', label='Path')
        ]
        ax.legend(handles=legend_elements, loc='center left', bbox_to_anchor=(1, 0.5))

        # Add path info
        if path:
            path_length = len(path) - 1
            ax.text(0.02, 0.98, f'Path Length: {path_length}',
                   transform=ax.transAxes, verticalalignment='top',
                   bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))
        else:
            ax.text(0.02, 0.98, 'No Path Found!',
                   transform=ax.transAxes, verticalalignment='top',
                   bbox=dict(boxstyle='round', facecolor='lightcoral', alpha=0.8))

        plt.tight_layout()
        plt.show()

        return path

# Example usage and demonstration
def create_sample_grid(rows: int = 15, cols: int = 15) -> np.ndarray:
    """Create a sample grid with obstacles"""
    grid = np.zeros((rows, cols))

    # Add some obstacles
    # Vertical walls
    grid[2:8, 5] = 1
    grid[7:13, 9] = 1

    # Horizontal walls
    grid[6, 1:6] = 1
    grid[10, 6:12] = 1

    # Random obstacles
    np.random.seed(42)
    for _ in range(15):
        r, c = np.random.randint(0, rows), np.random.randint(0, cols)
        grid[r, c] = 1

    return grid

if __name__ == "__main__":
    # Create sample grid
    grid = create_sample_grid(15, 15)

    # Initialize visualizer
    visualizer = AStarVisualizer(grid)

    # Define start and goal positions
    start = (1, 1)
    goal = (13, 13)

    # Ensure start and goal are not obstacles
    grid[start] = 0
    grid[goal] = 0

    # Visualize the pathfinding
    print("A* Pathfinding Visualization")
    print(f"Grid size: {grid.shape}")
    print(f"Start: {start}")
    print(f"Goal: {goal}")
    print(f"Obstacles: {np.count_nonzero(grid)}")

    path = visualizer.visualize_path(start, goal, figsize=(12, 10))

    if path:
        print(f"\nPath found with length: {len(path) - 1}")
        print("Path coordinates:")
        for i, pos in enumerate(path):
            print(f"  Step {i}: {pos}")
    else:
        print("\nNo path found!")